{% if mode == "saisie_resultats" %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/dictees.css') }}">

<style>
    /* =========================================================
   SAISIE R√âSULTATS ‚Äî overrides compacts au-dessus de dictees.css
   ========================================================= */

    /* Largeurs locales */
    :root {
        --w-col-moy: 140px;
        /* Moyenne */
        --w-col-abs: 74px;
        /* Absent  */
        --obj-count: 0;
        /* rempli en JS */
        --w-col-moy: 140px;
        /* Moyenne */
        --w-col-abs: 74px;
        /* Absent */
        --w-col-dictee: 80px;
        /* üëà largeur des colonnes objectifs */
        --obj-count: 0;
        /* rempli en JS */
    }

    /* ====== √âtirement du conteneur ====== */
    .page-dictees,
    .dictees-scope,
    #form-saisie-resultats {
        overflow: visible !important;
    }

    /* Conteneur : occupe toute la page et autorise le scroll horizontal */
    .table-container_d {
        width: 100vw;
        /* occupe toute la largeur visible */
        overflow-x: auto;
        /* scroll horizontal */
        overflow-y: visible;
        box-sizing: border-box;

    }


    /* Table : largeur selon son contenu (pas 100%) */
    .table-dictee_d {
        width: auto;
        /* ne colle pas √† 100% */
        min-width: max-content;
        /* >>> s‚Äô√©tire en fonction des colonnes r√©elles */
        border-collapse: collapse;
        table-layout: auto;
        /* laisse chaque colonne g√©rer sa largeur */
        vertical-align: bottom;
        /* colle le contenu en bas */
    }



    /* OPTIONNEL : pleine largeur viewport si ton layout limite la zone centrale.
   Active en ajoutant la classe `full-bleed` sur le conteneur (d√©j√† fait plus bas). */
    .table-container_d.full-bleed {

        /* centre et casse les paddings du parent (technique ‚Äúbleed‚Äù) */


        border-radius: 0;
        /* au cas o√π le parent a des coins arrondis */
    }

    /* ====== Bandeau titre coll√© aux colonnes fixes ====== */
    /* Bandeau titre : coll√© √† gauche, s'√©tire √† la taille du contenu */
    .table-container_d>.titre-niveau {
        position: sticky;
        left: 0;
        top: 0;
        z-index: var(--z-bandeau);

        /* largeur cal√©e sur le contenu */
        display: inline-block;
        width: max-content;
        /* cl√© pour suivre la longueur du texte */
        max-width: none;

        /* style */
        white-space: nowrap;
        /* pas de retour √† la ligne */
        padding: 6px 12px;
        margin: 0 0 0 0;
        background: var(--c-header);
        color: var(--c-text-on-header);
        border-radius: 6px 6px 0 0;
        font-weight: 800;
        font-size: 1.2em;
    }

    /* √âvite que le parent centre/√©tire l'inline-block */
    .table-container_d {
        text-align: left;
    }




    /* ====== En-t√™tes hautes + rotation 90¬∞ (Absent + Objectifs) ====== */
    .table-dictee_d thead th {
        height: 200px;
        vertical-align: bottom;
        overflow: visible;
        padding: 0 4px 6px 4px;
        background-clip: padding-box;
        font-size: 14px;

        /* taille globale des titres */
    }

    .th-abs_t>span,
    .entete-dictee_d>span {
        display: block;
        writing-mode: vertical-rl;
        transform: rotate(180deg);
        white-space: normal;
        word-break: break-word;
        height: calc(200px - 12px);
        margin: 0 auto;
        overflow: hidden;
    }

    /* ====== Colonnes sticky √âl√®ve / Moyenne / Absent ====== */
    .col-moy-titre_sr {
        position: sticky;
        left: var(--w-col-eleve);
        z-index: var(--z-groupe-th);
        width: var(--w-col-moy);
        min-width: var(--w-col-moy);
        max-width: var(--w-col-moy);
        background: var(--c-header);
        color: var(--c-text-on-header);
        font-size: 18px;
        box-shadow: 2px 0 5px -2px rgba(0, 0, 0, .08);
    }

    .col-moy_sr {
        position: sticky;
        left: var(--w-col-eleve);
        z-index: var(--z-groupe-td);
        width: var(--w-col-moy);
        min-width: var(--w-col-moy);
        max-width: var(--w-col-moy);
        background: #f7f7f7;
        height: 36px;
        padding: 0 6px;
        white-space: nowrap;
    }

    /* Absent ‚Äî ent√™te sticky (gauche) + au-dessus des objectifs */
    .col-abs-titre_sr {
        position: sticky;
        left: calc(var(--w-col-eleve) + var(--w-col-moy));
        z-index: calc(var(--z-groupe-th) + 3);
        /* plus haut que les th objectifs */
        background: var(--c-header);
        /* solide pour masquer dessous */
        color: var(--c-text-on-header);
        box-shadow: 2px 0 5px -2px rgba(0, 0, 0, .08);
        will-change: left;
    }

    /* Absent ‚Äî cellules du corps, m√™me position gauche + z-index */
    .col-abs_sr {
        position: sticky;
        left: calc(var(--w-col-eleve) + var(--w-col-moy));
        z-index: calc(var(--z-groupe-td) + 3);
        background: #fbfbfb;
        /* fond opaque */
        will-change: left;
    }


    .col-abs_sr input[type="checkbox"] {
        width: 16px;
        height: 16px;
        margin: 0;
        transform: translateY(2px);
    }

    /* Objectifs = m√™me gabarit que dictee */
    .th-obj_sr {
        width: var(--w-col-dictee);
        min-width: var(--w-col-dictee);
        max-width: var(--w-col-dictee);
    }

    /* Traits fins √† droite des sticky (lisibilit√©) */
    .col-eleve-titre_d,
    .col-eleve_d,
    .col-moy-titre_sr,
    .col-moy_sr,
    .col-abs-titre_sr,
    .col-abs_sr {
        position: sticky;
    }

    .col-eleve_d::after,
    .col-eleve-titre_d::after,
    .col-moy_sr::after,
    .col-moy-titre_sr::after,
    .col-abs_sr::after,
    .col-abs-titre_sr::after {
        content: "";
        position: absolute;
        top: 0;
        right: -1px;
        bottom: 0;
        width: 1px;
        background: #bbb;
    }

    /* Moyenne + disquette */
    .moy-wrap_sr {
        display: inline-flex;
        align-items: center;
        gap: 8px;
    }

    .moy-note_sr {
        min-width: 76px;
        text-align: right;
        font-variant-numeric: tabular-nums;
        display: inline-block;
    }

    .btn-save_sr {
        border: 1px solid var(--c-border);
        background: #f5f5f5;
        border-radius: 6px;
        padding: .15rem .35rem;
        font-size: 12px;
        line-height: 1;
        cursor: pointer;
    }

    .btn-save_sr:hover {
        background: #eee;
    }

    .save-state_sr {
        margin-left: 4px;
        font-size: 12px;
        color: #888;
    }

    /* S√©lecteurs NA/PA/A & absent */
    .niv-select_sr {
        width: 100%;
        height: 26px;
        font-size: 12px;
    }



    /* ====== MIN-WIDTH CALCUL√âE du tableau ======
   √©vite la ‚Äúcompression‚Äù quand il y a peu d‚Äôobjectifs visibles */
    .table-dictee_d {
        width: max-content !important;
        /* <<< cl√© pour √©viter la coupe */
        min-width: calc(var(--w-col-eleve) + var(--w-col-moy) + var(--w-col-abs) + (var(--obj-count) * var(--w-col-dictee))) !important;
        /* pas de width:100% ici, sinon le scroll arrive trop t√¥t */
    }

    /* L√©gende */
    #sr-legend {
        margin: 8px 0 0 0;
        font-size: 12px;
        color: #444;
    }

    html,
    body {
        overflow-x: auto;
        /* emp√™che un overflow-x:hidden global de couper la droite */
    }

    .col-eleve-titre_d,
    .col-moy-titre_sr {
        vertical-align: middle;
        /* centre verticalement */
        text-align: center;
        /* centre horizontalement */
        height: 100%;
        /* occupe toute la hauteur dispo */
    }


    /* Centre VRAIMENT le texte de "√âl√®ves" et "Moy." dans l'axe vertical et horizontal */
    .table-dictee_d thead th.col-eleve-titre_d,
    .table-dictee_d thead th.col-moy-titre_sr {
        vertical-align: middle !important;
        /* annule le bottom global */
        height: 200px;
        /* m√™me hauteur que les autres */
        padding: 0 8px;
        /* padding identique */
        box-sizing: border-box;


    }

    .champ-note {
        width: 40px;
        /* largeur du champ */
        height: 28px;
        /* hauteur du champ */
        text-align: center;
        /* texte centr√© */
        border: 1px solid #ccc;
        border-radius: 6px;
        /* coins arrondis */
        font-size: 14px;
        /* texte un peu plus petit */
        outline: none;
        /* pas de contour bleu */
        padding: 2px;
        box-sizing: border-box;
    }

    /* Z√©brure sur toutes les lignes du corps du tableau, sans impacter thead */
    .table-dictee_d tbody tr:nth-child(odd) td {
        background-color: #FFFFFF;
    }

    .table-dictee_d tbody tr:nth-child(even) td {
        background-color: #F5F5F5;
    }

    /* Voile gris + inaction √† partir de la 4e colonne quand absent */
    .table-dictee_d tbody tr.is-absent td:nth-child(n+4) {

        position: relative;
    }

    /* Rendre tout inactif dans ces cellules (pas de clic, pas de focus) */
    .table-dictee_d tbody tr.is-absent td:nth-child(n+4) * {
        pointer-events: none;
    }

    /* Aspect visuel des champs veill√©s */
    .table-dictee_d tbody tr.is-absent td:nth-child(n+4) input,
    .table-dictee_d tbody tr.is-absent td:nth-child(n+4) select,
    .table-dictee_d tbody tr.is-absent td:nth-child(n+4) textarea,
    .table-dictee_d tbody tr.is-absent td:nth-child(n+4) button {
        opacity: .6;
        cursor: not-allowed;
    }

    /* Palette des niveaux appliqu√©e aux champs */
    .champ-note.level-NA {
        background-color: #ff000075;
        color: #000;
    }

    .champ-note.level-PA- {
        background-color: #ff7d1aa6;
        color: #000;
    }

    .champ-note.level-PA {
        background-color: #ffe223;
        color: #000;
    }

    .champ-note.level-PA+ {
        background-color: #d4f5b0;
        color: #000;
    }

    .champ-note.level-A- {
        background-color: #a7e9b7;
        color: #000;
    }

    .champ-note.level-A {
        background-color: #5cc995;
        color: #000;
    }

    .champ-note.level-A+ {
        background-color: #3dbcb9;
        color: #000;
    }

    .champ-note.level-D {
        background-color: #00d3f8;
        color: #000;
    }

    /* Par d√©faut : fond blanc */
    .champ-note {
        background-color: #fff;
    }
</style>

<div class="page-dictees">
    <div class="dictees-scope">

        <form id="form-saisie-resultats" method="post" action="{{ url_for('main.saisir_resultats',
                         classe_id=classe.id,
                         evaluation_id=evaluation.id,
                         niveau=niveau) }}">
            {% if csrf_token is defined %}
            <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
            {% endif %}

            <!-- ACTIVE le ‚Äúfull-bleed‚Äù pour prendre toute la largeur du viewport -->
            <div class="table-container_d full-bleed">
                <div class="titre-niveau">
                    <span class="eval-title">{{ evaluation.titre or '√âvaluation' }}</span>
                    {% if evaluation.date %}<span class="eval-date">{{ evaluation.date }}</span>{% endif %}
                </div>

                <table class="table-dictee_d" aria-describedby="sr-legend">
                    <thead>
                        <tr>
                            <th class="col-eleve-titre_d">√âl√®ves</th>
                            <th class="col-moy-titre_sr">Moy.</th>
                            <th class="col-abs-titre_sr th-abs_t" title="Absent¬∑e"><span>ABSENT</span></th>
                            {% for obj in objectifs %}
                            <th class="entete-dictee_d th-obj_sr" data-type="simple"><span>{{ obj.texte }}</span></th>
                            {% endfor %}
                        </tr>
                    </thead>

                    <tbody>
                        {% for e in eleves %}
                        {% set est_absent = e.id in absents %}
                        <tr class="row-eleve_d {{ 'is-absent' if est_absent }}" data-eleve-id="{{ e.id }}">
                            <td class="col-eleve_d">
                                <input type="hidden" name="eleve[]" value="{{ e.id }}">
                                <span style="color:#00688B;font-weight:bold;">{{ e.prenom }}</span> {{ e.nom|upper }}
                                {% if e.niveau %}<small> ({{ e.niveau }})</small>{% endif %}
                            </td>

                            <td class="col-moy_sr">
                                <div class="moy-wrap_sr">
                                    <span class="moy-note_sr">‚Äî</span>

                                </div>
                            </td>

                            <td class="col-abs_sr">
                                <input type="checkbox" name="absent_{{ e.id }}" {{ 'checked' if est_absent }}>
                            </td>

                            {% for obj in objectifs %}
                            {% set v = resultats.get(e.id, {}).get(obj.id) %}
                            <td class="cell-dictee_d">
                                <input type="text" class="champ-note" maxlength="2" placeholder="">


                            </td>
                            {% endfor %}
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>

            <p id="sr-legend">
                √âchelle : NA=0, PA=2, A=4 ‚Äî moyenne ramen√©e sur 20. La disquette üíæ enregistre uniquement la ligne
                affich√©e.
            </p>

            <div style="margin:10px 0 0 0;">
                <button type="submit" class="btn btn-primary">Tout enregistrer</button>
            </div>
        </form>
    </div>
</div>

<script>
    (() => {
        /* 1) Pose --obj-count pour la min-width du tableau */
        const ths = document.querySelectorAll('.table-dictee_d thead th');
        const objCount = Math.max(0, ths.length - 3); // total - (√©l√®ve, moy, absent)
        document.documentElement.style.setProperty('--obj-count', objCount);

        const form = document.getElementById('form-saisie-resultats');
        if (!form) return;

        /* 2) Normalisation & mapping */
        const VALID = new Set(['NA', 'PA-', 'PA', 'PA+', 'A-', 'A', 'A+', 'D']);
        const NOTE_MAP = new Map([
            ['NA', 0],
            ['PA-', 1],
            ['PA', 2],
            ['PA+', 3],
            ['A-', 3.5],
            ['A', 4],
            ['A+', 4],
            ['D', 4],
        ]);

        /** Normalise une saisie libre en code attendu ou "" si invalide */
        function normalizeNote(raw) {
            if (!raw) return "";
            let v = String(raw).toUpperCase().replace(/\s+/g, ""); // enl√®ve espaces
            // Alias rapides
            if (v === 'N') v = 'NA';
            if (v === 'P') v = 'PA';
            if (v === 'P+' || v === 'P-') v = 'PA' + v[1]; // P+ -> PA+, P- -> PA-
            if (v === 'D') v = 'D';
            // Tol√®re "A +", "PA -" d√©j√† g√©r√©s par trim ci-dessus
            // Garde uniquement valeurs pr√©vues
            return VALID.has(v) ? v : "";
        }

        /** Coloration d'un input selon sa valeur (sans modifier la valeur) */
        function paintByValue(input) {
            const norm = normalizeNote(input.value);
            input.classList.remove(
                'level-NA', 'level-PA-', 'level-PA', 'level-PA+',
                'level-A-', 'level-A', 'level-A+', 'level-D'
            );
            if (norm) input.classList.add('level-' + norm);
        }

        /* 3) Calcul de moyenne par ligne */
        function calcRow(tr) {
            const fields = tr.querySelectorAll('.champ-note, .niv-select_sr');
            let sum = 0, n = 0;
            fields.forEach(f => {
                const v = normalizeNote((f.value || '').trim());
                if (v) { sum += NOTE_MAP.get(v); n++; }
            });
            const out = tr.querySelector('.moy-note_sr');
            if (!out) return;
            out.textContent = n === 0 ? '‚Äî' : ((sum / n) / 4 * 20).toFixed(1) + ' / 20';
        }

        /* 4) Init : couleur + moyenne pour chaque ligne */
        document.querySelectorAll('.champ-note').forEach(paintByValue);
        document.querySelectorAll('tr[data-eleve-id]').forEach(calcRow);

        /* 5) Live: recalcule √† chaque frappe + recoloration */
        document.addEventListener('input', (e) => {
            if (e.target.matches('.champ-note')) {
                paintByValue(e.target); // recolore selon la valeur actuelle
                const tr = e.target.closest('tr[data-eleve-id]');
                if (tr) calcRow(tr);
            }
            if (e.target.matches('.niv-select_sr')) {
                const tr = e.target.closest('tr[data-eleve-id]');
                if (tr) calcRow(tr);
            }
        });

        /* 6) Blur: normalise (n->NA, p->PA, etc.), recolore, recalcule */
        document.querySelectorAll('.champ-note').forEach(input => {
            input.addEventListener('blur', () => {
                const norm = normalizeNote(input.value);
                input.value = norm;      // impose la valeur normalis√©e
                paintByValue(input);     // remet la bonne couleur
                const tr = input.closest('tr[data-eleve-id]');
                if (tr) calcRow(tr);     // recalcule la moyenne
            });
        });

        /* 7) Gestion Absent: vide √† partir de la 4e col (CSS bloque l'√©dition), recalcule */
        document.addEventListener('change', (e) => {
            if (!e.target.matches('.col-abs_sr input[type="checkbox"]')) return;
            const tr = e.target.closest('tr[data-eleve-id]');
            if (!tr) return;

            if (e.target.checked) {
                tr.classList.add('is-absent');
                // vide tous les champs de note (text + select)
                tr.querySelectorAll('td:nth-child(n+4) .champ-note, td:nth-child(n+4) .niv-select_sr')
                    .forEach(el => { el.value = ""; if (el.classList) paintByValue(el); });
            } else {
                tr.classList.remove('is-absent');
            }
            calcRow(tr);
        });

        /* 8) Sauvegarde par ligne (AJAX) */
        async function saveRow(tr) {
            const saver = tr.querySelector('.save-state_sr');
            if (saver) saver.textContent = '‚Ä¶';

            const fd = new FormData();
            const csrf = form.querySelector('input[name="csrf_token"]');
            if (csrf) fd.append('csrf_token', csrf.value);

            const eleveId = tr.getAttribute('data-eleve-id');
            if (eleveId) fd.append('eleve[]', eleveId);

            const chk = tr.querySelector('.col-abs_sr input[type="checkbox"]');
            if (chk && chk.checked) fd.append('absent_' + eleveId, 'on');

            // on envoie ce qui a un name commen√ßant par "resultat_"
            tr.querySelectorAll('.niv-select_sr[name^="resultat_"], .champ-note[name^="resultat_"]').forEach(el => {
                // normalise avant d'envoyer
                const val = el.classList.contains('champ-note') ? normalizeNote(el.value) : el.value;
                fd.append(el.name, val || '');
            });

            try {
                const resp = await fetch(form.action, { method: 'POST', body: fd });
                if (!resp.ok) throw new Error('HTTP ' + resp.status);
                if (saver) { saver.textContent = '‚úîÔ∏é'; setTimeout(() => { saver.textContent = ''; }, 1200); }
            } catch (err) {
                if (saver) { saver.textContent = '‚ö†Ô∏é'; setTimeout(() => { saver.textContent = ''; }, 2000); }
                console.error(err);
            }
        }

        document.addEventListener('click', (e) => {
            const btn = e.target.closest('.btn-save_sr');
            if (!btn) return;
            const tr = btn.closest('tr[data-eleve-id]');
            if (tr) saveRow(tr);
        });
    })();
</script>
<script>
    /* ===== AUTOSAVE PATCH ‚Äî AUCUNE MODIF DE MISE EN PAGE ===== */
    (() => {
        const form = document.getElementById('form-saisie-resultats');
        if (!form) return;

        // On r√©utilise tes fonctions si elles existent, sinon on no-op.
        const has = fn => typeof window[fn] === 'function';
        const norm = has('normalizeNote') ? window.normalizeNote : (v) => v;
        const paint = has('paintByValue') ? window.paintByValue : () => { };
        const calc = has('calcRow') ? window.calcRow : () => { };
        const doSave = has('saveRow') ? window.saveRow : () => { };

        // Debounce par ligne (cl√© = data-eleve-id)
        const DEBOUNCE_MS = 300;
        const timers = new Map();
        const queueSave = (tr) => {
            if (!tr) return;
            const id = tr.getAttribute('data-eleve-id') || Math.random().toString(36).slice(2);
            clearTimeout(timers.get(id));
            timers.set(id, setTimeout(() => {
                doSave(tr);
            }, DEBOUNCE_MS));
        };

        // 1) √Ä chaque frappe dans un champ de note -> recolore, recalcule, autosave (debounced)
        document.addEventListener('input', (e) => {
            if (!e.target.closest('#form-saisie-resultats')) return;

            if (e.target.classList && e.target.classList.contains('champ-note')) {
                // recoloration si dispo
                paint(e.target);
                // recalcule la moyenne de la ligne
                const tr = e.target.closest('tr[data-eleve-id]');
                if (tr) {
                    calc(tr);
                    queueSave(tr);
                }
            }
            // Si tu as des <select> de niveaux .niv-select_sr on g√®re pareil
            if (e.target.classList && e.target.classList.contains('niv-select_sr')) {
                const tr = e.target.closest('tr[data-eleve-id]');
                if (tr) {
                    calc(tr);
                    queueSave(tr);
                }
            }
        }, true);

        // 2) Sur blur : normalise (si dispo), recolore, recalcule, autosave
        document.addEventListener('blur', (e) => {
            if (!e.target.closest || !e.target.closest('#form-saisie-resultats')) return;

            if (e.target.classList && e.target.classList.contains('champ-note')) {
                if (has('normalizeNote')) {
                    e.target.value = norm(e.target.value);
                }
                paint(e.target);
                const tr = e.target.closest('tr[data-eleve-id]');
                if (tr) {
                    calc(tr);
                    queueSave(tr);
                }
            }
        }, true);

        // 3) Coche "Absent" : vide les champs objectifs de la ligne (sans toucher au layout) + autosave
        document.addEventListener('change', (e) => {
            if (!e.target.closest || !e.target.closest('#form-saisie-resultats')) return;

            const isAbsCheckbox = e.target.matches('.col-abs_sr input[type="checkbox"]');
            if (!isAbsCheckbox) return;

            const tr = e.target.closest('tr[data-eleve-id]');
            if (!tr) return;

            if (e.target.checked) {
                tr.classList.add('is-absent');
                // Vide les champs objectifs de la ligne (texte + select), recolore au besoin
                tr.querySelectorAll('td:nth-child(n+4) .champ-note, td:nth-child(n+4) .niv-select_sr')
                    .forEach(el => {
                        el.value = '';
                        if (el.classList && el.classList.contains('champ-note')) paint(el);
                    });
            } else {
                tr.classList.remove('is-absent');
            }
            calc(tr);
            queueSave(tr);
        }, true);

        // 4) Option : emp√™cher "Enter" de soumettre le formulaire par accident lors de la saisie
        form.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.classList && e.target.classList.contains('champ-note')) {
                e.preventDefault();
                // on d√©clenche quand m√™me un save debounced de la ligne
                const tr = e.target.closest('tr[data-eleve-id]');
                if (tr) {
                    if (has('normalizeNote')) e.target.value = norm(e.target.value);
                    paint(e.target);
                    calc(tr);
                    queueSave(tr);
                }
            }
        });
    })();
</script>



{% endif %}